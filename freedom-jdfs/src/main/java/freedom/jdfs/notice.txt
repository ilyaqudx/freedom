jdfs开发过程中遇到的坑及注意点记录



1-NIO
	1.1:
		线程模型采用Reactor模型，ACCEPTOR接收请求后交给NIO线程进行处理。一定要注意对NIOsession
	初始化的完成后再放入NIO队列中，否则会出现意想不到的情况。之前STORAGE TASK就是在交给NIO线程后再
	初始的，遇到了接收客户端数据时STORAGE TASK length为0的情况。task的LENGTH又是依赖的SIZE的值，
	所以SIZE为0。多线程问题
	1.2:
		当新连接从队列取出后，一定要删除。否则会不断重复注册。导致数据错乱。
		在JDFS中未将NIOSESSION从NEWSESSION队列中清除，导致在多并发大文件上传时导致计算
		需要的数据出现了负数的情况。并且也多次导致STORAGE TASK BUFFER 没有可写空间，不停的
		CPU空转。当时自己已经清除了读事件，但是当TASK去DIO 线程写磁盘的时候还是不停的读事件通知过来
		，还以为是NIO哪儿不对，没有正确理解NIO的一些知识点。
		
		建议对STORAGE TASK 的OFFSET 和LENGTH的计算清除等工作，都由NIO线程处理。这样尽可能
		避免多线程导致的数据不一致问题
	1.3:
		在读取客户端数据时，可能一次读不完数据，所以大都在一个死循环中读取数据，直到读取完为止。
		但这样其实是有问题。如果当前处理的这个客户端一直读不到数据，则会一直在循环中空转，第一导致CPU空转，
		第二其他客户端无法得到处理。所以当读到数据长度为0时，这时则跳出循环，结束本次处理，下次再继续读取。
		这个在发送的数据时也是一样的，一次可能不能将所有数据发送完成，当发送的字节数为0时，此时跳出循环，
		等到下一次再继续写数据。
	1.4:
		从CHANNEL中读取数据长度为0或者写入到CHANNEL中长度为0，都有2种可能导致这个问题。
		读取到的长度为0：
			第一种情况是接收数据的BUFFER中没有多余空间。如果是这一种，则根据业务的逻辑作相应处理。比如在JDFS中，上传文件时如果读取到的字节数为0，
		是由于BUFFER中没有多余空间了，这种情况在JDFS中来说是不应该发生的，是程序出现了BUG。所以应当断开当前连接。
		
			第二种情况是内核缓冲区中确实没有数据，至少在本次读的时候确实没有数据(可能会有人问，既然没有数据，按NIO的特性，不应该会有可读事件发生的)
		所以这种情况应该是很少发生的。不过这儿作为提示。		
		
		写入的长度为0:
			第一种情况是存放数据的BUFFER中没有可写的数据，即POSITION=LIMIT。如果是这一种，同样根据业务规则进行相应处理。在JDFS中，下载文件
		时如果由于BUFFER中没有数据可写，这种情况是不应该发生的。是程序出现了BUG。所以应该断开当前连接。
		
			第二种情况是内核缓冲区中没有足够的空间存放数据，此时应该跳出循环。下一轮再来处理	
	1.5:
		一定要正确处理读取数据为-1的情况，正确的做法是关闭当前的连接，并且释放当前TASK中的资源(重置TASK状态，FILE CHANNEL打开的文件句柄需要关闭等,
		将TASK放回池等,记录错误日志以便查询)
	1.6:
		在处理和NIO有关的异常时,不能只CATCH IOException,最好在最后捕获EXCEPTION。这样抛出其他异常时也能得到反馈。特别是在线程池创建的线程里面如果
		没有正确捕获到异常，甚至会出现没有任何的错误信息输出的情况。
		
2-DIO(磁盘线程)
	2.1:文件句柄在正常结束和异常结束时都应该正常的释放.
	
3-
	3.1:
			线程模型的确定。一定要对项目架构的线程模型非常的熟悉，同时要对任务的不同状态的作用有比较清楚的认识。特别是对数据偏移量等的处理也一定要小心谨慎。一个字节
		都会引起错误.要确定在什么时候执行初始化，累加，重置操作任何一个环节出错都会直接导致数据错误

疑问:
	1:有没有可能在清除读事件时就已经有数据到来了，此时已经产生了读事件了。还是说只要清除了读事件，已存在的读事件也会清除掉。这个需要进一步验证
	2:当调用CHANNEL.CLOSE时，内核缓冲区的数据会刷新到客户端嘛?如果不会，那怎么样才能让所有数据发送完毕后再关闭呢？
	3:JAVA中回调的设计
	4:异常的正确处理
	5:代码的抽象分析和到底是用单例还是用STATIC访问的选择困难
	6:10个线程并发上传200个700K大小的文件，磁盘CPU使用率只有20%，说明大多在等待网络IO的数据.如何提高性能