bug-1 客户端发送消息到服务端,服务器接收到消息后,返回消息给客户端,这时服务器注册了写事件,当消息发送后.selector.select每次都会返回有WRITE事件,造成死循环

	原因:当监听了写事件后,底层判断可写时就会触发可写的事件,而可写的规则是当写缓冲区有空间即为可写,所以一直返回可写,造成了死循环
	
	解决:
		1-不注册写事件,只注册读事件(强烈建议)
		2-可以注册写事件,但写完后一定要将Key取消掉.
bug-2 当注册监听事件时,如果默认没有传入attchment,则默认设置为空,如果之前有设置过attchment,则会清空掉.这个要注意一下.

bug-3 写数据目前也是在NIOPROCESSOR线程中处理的,那么当不注册写监听事件时,如果及时的将数据写出去呢?很简单,调用Selector.wakeup方法唤醒线程即可.

bug-4 在自己写NIO框架时,如果用到了线程池来处理线程,在捕获异常时,一定要在最后捕获一个Exception异常,因为很多时间抛的异常是throwable,
		如果只捕获IOEXCEPTION则不会打印任何的异常信息.
		
bug-5 一定要注意,要用reactor线程接收缓存区的消息进行编码处理,处理一个完整的包后,再用工作线程异步处理.否则可能会引起数据的错乱.无法保证
		消息的顺序.
		
bug-6 当接收了客户端的连接后,需要设置SocketChannel为configurationBlocking为false.为非阻塞模式.否则会报错.

bug-7 在Connector的ConnectorReactor中,将SESSION注册到PROCESSOR里面,代码如下:此方法调用后,则会将SESSION放入PROCESSOR的新增队列,
			public void regiestSession(NioSession session)
			{
				//bug-1
				newSessionQueue.add(session);
				NioProcessor v = reference.get();
				if(v == null){
					if(reference.compareAndSet(null,this))
						this.startup();
				}
				sel.wakeup();
			}
			
			然后在NIOPROCESSOR里面循环处理新增的SESSION.一个是在CONNECTOR_REACTOR线程里,一个是处理IO读写的线程.所以出现了并发的问题
			int n = sel.select(500L);
				
				if(n > 0){
					process();
				}
				
				handleNewSession();
				
				flush0();
				
				
			在handleNewSession方法被调用时,新注册的SESSION注册到NIOPROCESSOR的SELECTOR的读事件,这时将SELECTOR赋值给SESSION.
			而FLUSH0方法是处理SESSION的写数据的方法.里面用到了PROCESSOR的SELECTOR.因为2个线程的原因.在上一次handleNewSession结束后,
			新增加的SESSION已经有数据要写,但这时处理新连接的方法刚刚调用完,只有等下一次调用才会设置SELECTOR到SESSION里面,所以会报NullPointerException.
			
			
bug-8	如果也由IO线程负责了简单业务的处理操作后返回,由IO线程返回FUTURE，如果这时调用FUTURE。await方法,那么IO线程被阻塞 。测试MINA是否会阻塞 .


bug-9   非常重要:采用文本行协议,客户端为BIO方式下IN,OUT分别采用不同线程,客户端每隔50MS发送一次请求,服务器接收不到消息?但是服务器每50MS发送消息,客户端可以接收到.


		发送不出数据的原因:

		客户端采用BIO,IN,OUT分别用不同的线程处理.当IN调用read方法时,此时SocketChannelImp中使用FD描述符进行了同步,而在调用WRITE方法时,也会去获取到FD这把锁,
		因为服务器一直没有消息发送到客户端,所以OUT线程不能获取到这把FD锁,导致一直等待状态,无法进行消息通信.
		
		解决方法:
			1-在每次读操作前进行调用WAIT等待50MS,此间OUT可以进行消息发送,50MS后,服务器也有数据返回,此时READ方法读取到了数据,则可以保持通信.
			  但此方案可能仍然会出问题,就是在OUT线程刚好准备写时,IN先行调用读取方法,占有了FD锁,但服务器已没有数据返回.则OUT还是无法将数据写出.导致线程一致等待.
			  所以客户端在BIO模式下不适合发送请求和接收请求在不同的线程.而是采用REQ-RES方式来处理.如果请求比较多.可以采用连接池的方式来处理,才是比较好的解决方式.
			  
			  
			2-:想到设置SOCKET的读取超时时间来控制READ的阻塞(超时后会抛出SocketTimeoutException),但是设置之后 ,SOCKET就关闭了,需要重新建立 连接 .所以不适用.
			3-:再想到用调用inputream的avaiable方法返回当前可读的字节数,如果有数据可读(>0)则再去调用inputstream.read方法,此方法看起来是非常可靠的.但是事实是这样的:
				InputStream默认返回0,JDK文档也说明,应该调用子类的实现,然后用BufferedInputStream包装后调用,同样的效果还是每次都返回0.
				所以结果是InputStream包括它的子类的avaiable方法返回可用的字节数,此方法慎用,几乎每次都会返回0.
			 
			 
		可以不停接收数据的原因:
			因为在接收数据的时候,OUT并没有发送数据,或者即使发送数据那么很快就会释放FD锁,那么READ则可以一直读取.所以也说明了,一定要服务器有数据回来,将IN的读取操作唤醒,
			才能使用BIO比较正常的接收数据.










